#ifndef _H_KMQ_
#define _H_KMQ_

#include <iostream>
#include <inttypes.h>

using namespace std;

#include <kmq/errno.h>


namespace kmq {

enum {
    OPT_TIMEOUT = 1,
    OPT_NONBLOCK = 2,
    OPT_AUTORECONNECT = 3,
    OPT_SOCKCACHE = 4,
};


enum FLAG_BITS {
    FLAG_BIT1 = 0x0001,
    FLAG_BIT2 = 0x0002,
    FLAG_BIT3 = 0x0004,
    FLAG_BIT4 = 0x0008,
    FLAG_BIT5 = 0x0010,
    FLAG_BIT6 = 0x0020,
    FLAG_BIT7 = 0x0040,
    FLAG_BIT8 = 0x0080,
    FLAG_BIT9 = 0x0100,
    FLAG_BIT10 = 0x0200,
    FLAG_BIT11 = 0x0400,
    FLAG_BIT12 = 0x0800,
    FLAG_BIT13 = 0x1000,
    FLAG_BIT14 = 0x2000,
    FLAG_BIT15 = 0x4000,
    FLAG_BIT16 = 0x8000,
};
 
struct kmqhdr {
    uint8_t version;
    uint8_t ttl;
    uint16_t flags;
    uint32_t size;
    uint16_t hdrcheck;
    uint16_t datacheck;
    uint64_t seqid;
    uint64_t timestamp;
    union {
	char __padding[8];
    } _u;
};

class SpioComsumer {
 public:
    virtual ~SpioComsumer() {}

    // Appid: appname.
    // AppHost: kmq server ip:port address. 
    // When successful, Connect() returns zero. When an error
    // occurs, Connect() returns -1 and _errno is set appropriately.
    virtual int Connect(const string &appname, const string &apphost) = 0;

    // Close() API close the raw socket. you can Connect() to
    // the kmq server again
    virtual int Close() = 0;

    // Recv request massage from kmq server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    // here rt specify the route infomation
    virtual int RecvMsg(string &msg, string &rt) = 0;

    // Send response massage to kmq server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    // send msg with rt generated by RecvMsg() API
    virtual int SendMsg(const string &msg, const string &rt) = 0;
    virtual int SendMsg(const char *data, uint32_t len, const string &rt) = 0;

    
    virtual int SetOption(int opt, ...) = 0;
    virtual int GetOption(int opt, ...) = 0;
};

SpioComsumer *NewSpioComsumer();


class SpioProducer {
 public:
    virtual ~SpioProducer() {}

    // Appid: appname.
    // AppHost: kmq server ip:port address. 
    // When successful, Connect() returns zero. When an error
    // occurs, Connect() returns -1 and _errno is set appropriately.
    virtual int Connect(const string &appname, const string &apphost) = 0;

    // Close() API close the raw socket. you can Connect() to
    // the kmq server again
    virtual int Close() = 0;

    // Send request massage from kmq server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    virtual int SendMsg(const string &msg) = 0;
    virtual int SendMsg(const char *data, uint32_t len) = 0;

    // Recv response massage to kmq server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    virtual int RecvMsg(string &msg) = 0;


    virtual int SetOption(int opt, ...) = 0;
    virtual int GetOption(int opt, ...) = 0;
};

SpioProducer *NewSpioProducer();


}
 

#endif  // _H_KMQCLIENT_
